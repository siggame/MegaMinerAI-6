#include "lzw.h"

#include <algorithm>
#include <iterator>
#include <vector>

#include <stdint.h>
#include <arpa/inet.h> //for htonl

using namespace std;

lzwCompressor::lzwCompressor()
{
  dictSize = 256;
  for (int i = 0; i < 256; i++)
    dictionary[string(1, i)] = i;
}

string lzwCompressor::compress(string in)
{
  string w;
  
  vector<uint32_t> buf;
  back_insert_iterator<vector<uint32_t> > result = back_inserter(buf);
  
  for (string::const_iterator it = in.begin();
       it != in.end(); ++it)
  {
    char c = *it;
    std::string wc = w + c;
    if (dictionary.count(wc))
      w = wc;
    else
    {
      *result++ = htonl(dictionary[w]);
      // Add wc to the dictionary.
      dictionary[wc] = dictSize++;
      w = std::string(1, c);
    }
  }
  if (!w.empty())
    *result++ = dictionary[w];
  
  string out((const char*)&buf[0], 4 * buf.size());
  return out;
}

lzwDecompressor::lzwDecompressor()
{
  dictSize = 256;
  for (int i = 0; i < 256; i++)
    dictionary[i] = string(1, i);
}

string lzwDecompressor::decompress(string in)
{
  uint32_t* begin = (uint32_t*)in.c_str();
  uint32_t* end = begin + (in.size() / 4);
  
  std::string w = dictionary[ntohl(*begin++)];
  std::string result = w;
  std::string entry;
  for ( ; begin < end; begin++)
  {
    int k = ntohl(*begin);
    if (dictionary.count(k))
      entry = dictionary[k];
    else if (k == dictSize)
      entry = w + w[0];
    else
      throw "Bad compressed k";
 
    result += entry;
 
    // Add w+entry[0] to the dictionary.
    dictionary[dictSize++] = w + entry[0];
 
    w = entry;
  }
  return result;
}