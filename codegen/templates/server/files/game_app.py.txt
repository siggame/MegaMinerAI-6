#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
from networking.sexpr.sexpr import sexpr2str
from networking.dispatch import SexpProtocol
from networking.apps import BaseApp, protocolmethod, namedmethod, AccountsAppMixin
from itertools import repeat
import functools
import game_app.match
Match = game_app.match.Match
from game_app.game_app_utils import errorBuffer, requireLogin, requireGame, \
                  requireTurn, requireTypes
import time
import struct
import bz2

class GameApp(AccountsAppMixin, BaseApp):
  games = {}
  nextid = 1

  def __init__(self, protocol):
    BaseApp.__init__(self, protocol)
    AccountsAppMixin.__init__(self)
    self.game = None
    self.user = self.name
    self.screenName = self.name

  @protocolmethod
  @requireLogin
  def createGame(self):
    """ Creates a game """
    if self.game is not None:
      return ("create-game-denied", "You are already in a game.")
    else:
      print "Creating game %d"%(GameApp.nextid,)
      self.user = self.name
      self.screenName = self.name
      self.game = Match(GameApp.nextid, self)
      self.game.addPlayer(self)
      GameApp.games[GameApp.nextid] = self.game
      GameApp.nextid += 1
      return ("create-game", self.game.id)

  @protocolmethod
  @requireLogin
  @requireTypes(None, int)
  def joinGame(self, gameNumber):
    """ Joins the specified game"""    
    if self.game is not None:
      return ["join-game-denied", "You are already in a game"]
    try:
      self.user = self.name
      self.screenName = self.name
      self.game = GameApp.games[gameNumber]
      self.game.addPlayer(self)
    except KeyError:
      return ["join-game-denied", "No such game"]

  @protocolmethod
  @errorBuffer
  @requireGame
  def leaveGame(self):
    """ Leaves the current game """
    if self.game is None:
      return "Not in a game"
    reply = self.game.removePlayer(self)
    if ((self.game.players) == 0):
      del GameApp[self.game.id]
    self.game = None
    return reply

  @protocolmethod
  @errorBuffer
  @requireGame
  def gameStart(self):
    """Starts game associated with this connections """
    return self.game.start()

  @protocolmethod
  @errorBuffer
  @requireGame
  def gameStatus(self):
    """ Requests the status of your game """
    self.game.sendStatus([self])

  @protocolmethod
  @errorBuffer
  @requireTurn
  def endTurn(self):
    """ Attempts to end your turn """
    return self.game.nextTurn()

% for model in models:
%   for func in model.functions:
%     if not model.parent or func not in model.parent.functions:
  @protocolmethod
  @errorBuffer
  @requireTurn
  @requireTypes(None, int\
%       for arg in func.arguments:  
, \
${conversions[arg.type]}\
%       endfor
)
  def game${capitalize(func.name)}(self, ${lowercase(model.name)}\
%       for arg in func.arguments:  
, \
${arg.name}\
%       endfor
):
    """${func.doc}"""
    return self.game.${func.name}(${lowercase(model.name)}\
%       for arg in func.arguments:  
, \
${arg.name}\
%       endfor
)

%     endif
%   endfor
% endfor

  @protocolmethod
  def whoami(self):
    """ Returns this connection's session identifiers """
    if self.name:
      return ("num", self.protocol.session_num), ("name", self.name)
    else:
      return ("num", self.protocol.session_num), ("name", "noone")

  @protocolmethod
  @requireLogin
  @requireTypes(None, str)
  def requestLog(self, logID):
    """ Requests a specific gamelog """ 
    infile = bz2.BZ2File("logs/" + logID + ".gamelog.bz2", "r")
    return ['log', logID, infile.read()]

  def writeSExpr(self, message):
    """ Adds backward compatibility with game logic written for the old
    server code
    """
    payload = sexpr2str(message)
    self.protocol.sendString(payload)

class TestGameServer(SexpProtocol):
  app = GameApp

if __name__ == "__main__":
  TestGameServer.main(19000)
