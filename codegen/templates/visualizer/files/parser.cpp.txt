#include "parser.h"
#include "sexp/sexp.h"
#include "sexp/parser.h"
#include "sexp/sfcompat.h"

#include <cstdio>
#include <cstdlib>
#include <cstring>

using namespace std;


% for model in models:
static void parse${model.name}(${model.name}& object, sexp_t* expression)
{
  sexp_t* sub;
  sub = expression->list;
  
%   for datum in model.data:
%     if datum.type == int:
  object.${datum.name} = atoi(sub->val);
%     elif datum.type == float:
  object.${datum.name} = atof(sub->val);
%    elif datum.type == str:
  object.${datum.name} = new char[strlen(sub->val)+1];
  strncpy(object.${datum.name}, sub->val, strlen(sub->val));
  object.${datum.name}[strlen(sub->val)] = 0;
%    endif
  sub = sub->next;
%  endfor
  
}
% endfor

% for animation in animations:
static void parse${capitalize(animation.name)}(${animation.name}& object, sexp_t* expression)
{
  sexp_t* sub;
  sub = expression->list;
  
%   for datum in animation.data:
%     if datum.type == int:
  object.${datum.name} = atoi(sub->val);
%     elif datum.type == float:
  object.${datum.name} = atof(sub->val);
%    elif datum.type == str:
  object.${datum.name} = new char[strlen(sub->val)+1];
  strncpy(object.${datum.name}, sub->val, strlen(sub->val));
  object.${datum.name}[strlen(sub->val)] = 0;
%    endif
  sub = sub->next;
%  endfor
  
}
% endfor

static bool parseSexp(Game& game, sexp_t* expression)
{
  sexp_t* sub, *subsub;
  expression = expression->list;
  if(expression->val != NULL && strcmp(expression->val, "status") == 0)
  {
    GameState gs;
    while(expression->next != NULL)
    {
      expression = expression->next;
      sub = expression->list;
      if(string(sub->val) == "game")
      {
% for datum in globals:
%   if datum.type == int:
          gs.${datum.name} = atoi(sub->val);
%   elif datum.type == float:
          gs.${datum.name} = atof(sub->val);
%   elif datum.type == str:
          if(c->${datum.name}) delete[] c->${datum.name};
          gs.${datum.name} = new char[strlen(sub->val)+1];
          strncpy(gs.${datum.name}, sub->val, strlen(sub->val));
          gs.${datum.name}[strlen(sub->val)] = 0;
%   endif
          sub = sub->next;
          
% endfor
      }
% for model in models:
      else if(string(sub->val) == "${model.name}")
      {
        sub = sub->next;
        while(sub)
        {
          ${model.name} object;
          parse${model.name}(object, sub);
          gs.${lowercase(model.plural)}.push_back(object);
          
          sub = sub->next;
        }
      }
% endfor
    }
    game.states.push_back(gs);
  }
  else if(string(expression->val) == "animations")
  {
    std::vector<Animation*> animations;
    while(expression->next)
    {
      expression = expression->next;
      sub = expression->list;
% for animation in animations:
      if(string(sub->val) == "${dashify(animation.name)}")
      {
        ${animation.name}* animation = new ${animation.name};
        parse${capitalize(animation.name)}(*animation, sub);
        animations.push_back(animation);
      }
% endfor
    }
    game.states[game.states.size()-1].animations = animations;
  }
  else if(string(expression->val) == "ident")
  {
    expression = expression->next;
    sub = expression->list;
    while(sub)
    {
      subsub = sub->list;
      int number = atoi(subsub->val);
      if(number > 0)
      {
        subsub = subsub->next->next;
        game.players[number] = subsub->val;
      }
      sub = sub->next;
    }
  }
  else if(string(expression->val) == "game-winner")
  {
    expression = expression->next;
    game.winner = atoi(expression->val);
  }
}


bool parseFile(Game& game, const char* filename)
{
  bool value;
  FILE* in = fopen(filename, "r");
  int size;
  if(!in)
    return false;
  
  parseFile(in);
  
  sexp_t* st = NULL;
  
  while(st = parse())
  {
    cout << i++ << endl;
    parseSexp(game, st);
    destroy_sexp(st);
  }
  
  fclose(in);
  
  return true;
}


bool parseString(Game& game, const char* string)
{
  sexp_t* st = NULL;
  
  st = extract_sexpr(string);

  while(st)
  {
    cout << i++ << endl;
    parseSexp(game, st);
    destroy_sexp(st);
    st = parse();
  }
  
  return true;
}